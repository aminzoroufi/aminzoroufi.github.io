<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>halfrost | Dezhi Yu</title><link>https://halfrost.me/author/halfrost/</link><atom:link href="https://halfrost.me/author/halfrost/index.xml" rel="self" type="application/rss+xml"/><description>halfrost</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2024 · Dezhi Yu</copyright><lastBuildDate>Wed, 15 Jan 2020 13:30:00 +0000</lastBuildDate><image><url>https://halfrost.me/images/icon_hu545dc38133db00f2a0f3ba46257a5641_68992_512x512_fill_lanczos_center_2.png</url><title>halfrost</title><link>https://halfrost.me/author/halfrost/</link></image><item><title>Segment Tree Basics</title><link>https://halfrost.me/talk/segment-tree-basics/</link><pubDate>Wed, 15 Jan 2020 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/segment-tree-basics/</guid><description/></item><item><title>Redis Multi-Data Center Two-Way Synchronization</title><link>https://halfrost.me/talk/redis-multi-data-center-two-way-synchronization/</link><pubDate>Thu, 31 Oct 2019 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/redis-multi-data-center-two-way-synchronization/</guid><description/></item><item><title>Redis Design Ideas and Usage Specifications</title><link>https://halfrost.me/talk/redis-design-ideas-and-usage-specifications/</link><pubDate>Tue, 18 Jun 2019 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/redis-design-ideas-and-usage-specifications/</guid><description/></item><item><title>Detailed HTTP/2 header compression algorithm-HPACK</title><link>https://halfrost.me/post/detailed-http-2-header-compression-algorithm-hpack/</link><pubDate>Sun, 16 Jun 2019 10:05:36 +0000</pubDate><guid>https://halfrost.me/post/detailed-http-2-header-compression-algorithm-hpack/</guid><description>&lt;p>在 HTTP/1.1（请参阅 &lt;a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener">RFC7230&lt;/a>）中，header 字段未被压缩。随着网页内的请求数增长到需要数十到数百个请求的时候，这些请求中的冗余 header 字段不必要地消耗了带宽，从而显着增加了延迟。&lt;/p>
&lt;p>&lt;a href="https://tools.ietf.org/html/rfc7541#ref-SPDY" target="_blank" rel="noopener">SPDY&lt;/a> 最初通过使用 &lt;a href="https://tools.ietf.org/html/rfc7541#ref-DEFLATE" target="_blank" rel="noopener">DEFLATE&lt;/a> 格式压缩 header 字段来解决此冗余问题，事实证明，这种格式非常有效地表示了冗余 header 字段。但是，这种方法暴露了安全风险，如 CRIME（轻松实现压缩率信息泄漏）攻击所证明的安全风险（请参阅 &lt;a href="https://tools.ietf.org/html/rfc7541#ref-CRIME" target="_blank" rel="noopener">CRIME&lt;/a>）。&lt;/p>
&lt;p>本规范定义了 HPACK，这是一种新的压缩方法，它消除了多余的 header 字段，将漏洞限制到已知的安全攻击，并且在受限的环境中具有有限的内存需求。&lt;a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP:2_Header-Compression.md#1-%E6%8E%A2%E6%B5%8B%E5%8A%A8%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">第 7 节&lt;/a>介绍了 HPACK 的潜在安全问题。&lt;/p>
&lt;p>HPACK 格式特意被设计成简单且不灵活的形式。两种特性都降低了由于实现错误而引起的互操作性或安全性问题的风险。没有定义扩展机制；只能通过定义完整的替换来更改格式。&lt;/p>
&lt;p>点击&lt;a href="https://halfrost.com/http2-header-compression/" target="_blank" rel="noopener">阅读更多&lt;/a>看全文。&lt;/p></description></item><item><title>Golang Message Streaming Practice in Eleme</title><link>https://halfrost.me/talk/golang-message-streaming-practice-in-eleme/</link><pubDate>Fri, 15 Mar 2019 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/golang-message-streaming-practice-in-eleme/</guid><description/></item><item><title>SQL Practical Optimization</title><link>https://halfrost.me/talk/sql-practical-optimization/</link><pubDate>Tue, 25 Dec 2018 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/sql-practical-optimization/</guid><description/></item><item><title>How to understand gradient descent?</title><link>https://halfrost.me/post/how-to-understand-gradient-descent/</link><pubDate>Sun, 21 Oct 2018 10:05:36 +0000</pubDate><guid>https://halfrost.me/post/how-to-understand-gradient-descent/</guid><description>&lt;p>Gradient descent is a first-order iterative optimization algorithm for finding a local minimum of a differentiable function. To find a local minimum of a function using gradient descent, we take steps proportional to the negative of the gradient (or approximate gradient) of the function at the current point. But if we instead take steps proportional to the positive of the gradient, we approach a local maximum of that function; the procedure is then known as gradient ascent. Gradient descent is generally attributed to Cauchy, who first suggested it in 1847, but its convergence properties for non-linear optimization problems were first studied by Haskell Curry in 1944.&lt;/p>
&lt;p>Click &lt;a href="https://halfrost.com/gradient_descent/" target="_blank" rel="noopener">read more&lt;/a> to read full article.&lt;/p></description></item><item><title>TLS 1.3 Handshake Protocol</title><link>https://halfrost.me/post/tls-1.3-handshake-protocol/</link><pubDate>Sun, 21 Oct 2018 10:05:36 +0000</pubDate><guid>https://halfrost.me/post/tls-1.3-handshake-protocol/</guid><description>&lt;p>握手协议用于协商连接的安全参数。握手消息被提供给 TLS 记录层，在记录层它们被封装到一个或多个 TLSPlaintext 或 TLSCiphertext 中，它们按照当前活动连接状态进行处理和传输。&lt;/p>
&lt;pre>&lt;code class="language-c"> enum {
client_hello(1),
server_hello(2),
new_session_ticket(4),
end_of_early_data(5),
encrypted_extensions(8),
certificate(11),
certificate_request(13),
certificate_verify(15),
finished(20),
key_update(24),
message_hash(254),
(255)
} HandshakeType;
struct {
HandshakeType msg_type; /* handshake type */
uint24 length; /* remaining bytes in message */
select (Handshake.msg_type) {
case client_hello: ClientHello;
case server_hello: ServerHello;
case end_of_early_data: EndOfEarlyData;
case encrypted_extensions: EncryptedExtensions;
case certificate_request: CertificateRequest;
case certificate: Certificate;
case certificate_verify: CertificateVerify;
case finished: Finished;
case new_session_ticket: NewSessionTicket;
case key_update: KeyUpdate;
};
} Handshake;
&lt;/code>&lt;/pre>
&lt;p>协议消息必须按照一定顺序发送(顺序见下文)。如果对端发现收到的握手消息顺序不对，必须使用 “unexpected_message” alert 消息来中止握手。&lt;/p>
&lt;p>点击&lt;a href="https://halfrost.com/tls_1-3_handshake_protocol/" target="_blank" rel="noopener">阅读更多&lt;/a>看全文。&lt;/p></description></item><item><title>Fundamentals of Cryptography</title><link>https://halfrost.me/talk/fundamentals-of-cryptography/</link><pubDate>Sun, 15 Jul 2018 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/fundamentals-of-cryptography/</guid><description/></item><item><title>The Practice of Spatial Index in Geographic Service</title><link>https://halfrost.me/talk/the-practice-of-spatial-index-in-geographic-service/</link><pubDate>Sun, 14 Jan 2018 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/the-practice-of-spatial-index-in-geographic-service/</guid><description/></item><item><title>Getting started with Machine Learning</title><link>https://halfrost.me/talk/getting-started-with-machine-learning/</link><pubDate>Wed, 08 Nov 2017 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/getting-started-with-machine-learning/</guid><description/></item><item><title>How to design and implement a thread-safe Map data structure</title><link>https://halfrost.me/post/how-to-design-and-implement-a-thread-safe-map-data-structure/</link><pubDate>Sun, 10 Sep 2017 10:05:36 +0000</pubDate><guid>https://halfrost.me/post/how-to-design-and-implement-a-thread-safe-map-data-structure/</guid><description>&lt;p>Map 是一种很常见的数据结构，用于存储一些无序的键值对。在主流的编程语言中，默认就自带它的实现。C、C++ 中的 STL 就实现了 Map，JavaScript 中也有 Map，Java 中有 HashMap，Swift 和 Python 中有 Dictionary，Go 中有 Map，Objective-C 中有 NSDictionary、NSMutableDictionary。&lt;/p>
&lt;p>上面这些 Map 都是线程安全的么？答案是否定的，并非全是线程安全的。那如何能实现一个线程安全的 Map 呢？想回答这个问题，需要先从如何实现一个 Map 说起。&lt;/p>
&lt;p>点击&lt;a href="https://halfrost.com/go_map_chapter_one/" target="_blank" rel="noopener">阅读更多&lt;/a>看全文。&lt;/p></description></item><item><title>Functional Reactive Programming Thinking</title><link>https://halfrost.me/talk/functional-reactive-programming-thinking/</link><pubDate>Thu, 15 Jun 2017 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/functional-reactive-programming-thinking/</guid><description/></item><item><title>Eleme Quarterly Newcomer Report</title><link>https://halfrost.me/talk/eleme-report/</link><pubDate>Tue, 18 Apr 2017 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/eleme-report/</guid><description/></item><item><title>Weex layout engine powered by FlexBox algorithm</title><link>https://halfrost.me/post/weex-layout-engine-powered-by-flexbox-algorithm/</link><pubDate>Fri, 31 Mar 2017 10:05:36 +0000</pubDate><guid>https://halfrost.me/post/weex-layout-engine-powered-by-flexbox-algorithm/</guid><description>&lt;p>在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。&lt;/p>
&lt;p>打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。&lt;/p>
&lt;p>Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。&lt;/p>
&lt;p>当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。&lt;/p>
&lt;p>点击&lt;a href="https://halfrost.com/weex_flexbox/" target="_blank" rel="noopener">阅读更多&lt;/a>看全文。&lt;/p></description></item><item><title>iOS Architecture Smalltalk</title><link>https://halfrost.me/talk/ios-architecture-smalltalk/</link><pubDate>Thu, 25 Aug 2016 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/ios-architecture-smalltalk/</guid><description/></item><item><title>Phabricator Introduce</title><link>https://halfrost.me/talk/phabricator-introduce/</link><pubDate>Wed, 20 Jan 2016 13:30:00 +0000</pubDate><guid>https://halfrost.me/talk/phabricator-introduce/</guid><description/></item></channel></rss>